![Static Badge](https://img.shields.io/badge/ts-3178C6?logo=typescript&logoColor=white)
![Static Badge](https://img.shields.io/badge/version-1.0-blue)

# Graph Theory. Алгоритмы теории графов

### 🛠 Реализованные алгоритмы
Проект поделён на 11 тасков, в каждом из которых реализованы определенные алгоритмы:

1. Программа, рассчитывающая следующие характеристики графа/орграфа: вектор степеней вершин, матрицу расстояний, диаметр, радиус, множество центральных вершин (для графа), множество периферийных вершин (для графа). Расчёт производится ```алгоритмом Флойда-Уоршелла```.
2. Программа, определяющая связность. Для графа – связность, а также количество и состав компонент связности. Используется поиск в ширину ```BFS```. Для орграфа – сильную, слабую связность, или несвязность. А также количество и состав компонент связности и сильной связности. Используется алгоритм ```Косарайю / Косараджу```.
3. Программа, находящая мосты и шарниры в графе. Для орграфа находятся мосты и шарниры в соотнесённом графе. 
4. Программа, находящая остовное дерево графа. Для орграфа находится остовное дерево соотнесённого графа. Используются: ```алгоритм Крускала```, ```алгоритм Прима```, ```алгоритм Борувки```.
5. Программа, находящая геодезическую цепь между двумя вершинами в графе. Поиск производится ```алгоритмом Дейкстры```.
6. Программа, рассчитывающая расстояние от указанной вершины до всех остальных вершин в графе. Используются: ```алгоритм Дейкстры```, ```алгоритм Беллмана-Форда-Мура```, ```алгоритм Левита```.
7. Программа, рассчитывающая расстояние между всеми парами вершин в графе. Поиск производится ```алгоритмом Джонсона```.
8. Программа, рассчитывающая расстояние между двумя точками на карте. Поиск производится ```алгоритмом 𝐴*```.
9. Программа, находящая гамильтонов путь в графе. Используется ```алгоритм муравьиной колонии```.
10. Программа, рассчитывающая максимальный поток в сети. Расчёт выполняется ```алгоритмом Форда-Фалкерсона```. Источник и сток определяются автоматически.
11. Программа, находящая максимальные паросочетания. Перед этим определяется, является ли граф двудольным.

*** 

### 📦 Основные модули

>
> ___Graph___
> 
> Модуль, который описывает класс графа и реализует основные методы над ним:
> * ```weight(vi, vj)``` – весовая функция, принимает номера вершин, возвращает вес ребра, связывающего их;
> * ```is_edge(vi, vj)``` – функция, принимающая номера вершин и возвращает True, если в графе есть соответствующее ребро/дуга, False, если ребра нет;
> * ```adjacency_matrix()``` – функция, возвращающая матрицу смежности графа/орграфа;
> * ```adjacency_list(v)``` – функция, возвращающая список вершин, смежных вершине v;
> * ```list_of_edges()``` – функция, возвращающая список всех рёбер графа;
> * ```list_of_edges(v)``` – функция, возвращающая список всех рёбер графа, инцидентных вершине v / исходящих из вершины v.
> * ```is_directed()``` – функция, возвращающая True, если граф ориентированный, False, если граф простой;
>

>
> ___MapGrid___
> 
> Используется в 8 задании. 
> 
> Модуль, который описывает класс карты с клетками и их координатами. Реализует следующие методы:
> * ```neighbors(c)``` – функция, возвращающая список клеток, соседних клетке c;
> * ```height(i, j)``` – функция, возвращающая высоту карты в точке (i; j);
> * ```distance(u: Cell, v: Cell)``` - функция, возвращающая расстояние между клетками u и v;
>

